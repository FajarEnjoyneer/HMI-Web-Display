[
    {
        "id": "7d3b649d45b9e551",
        "type": "http in",
        "z": "add6d26f2860e685",
        "name": "GET /display",
        "url": "/boiler",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 100,
        "wires": [
            [
                "2203bef30d5e0ce4"
            ]
        ]
    },
    {
        "id": "c239e5aefe9fe3a5",
        "type": "http response",
        "z": "add6d26f2860e685",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 550,
        "y": 100,
        "wires": []
    },
    {
        "id": "2203bef30d5e0ce4",
        "type": "template",
        "z": "add6d26f2860e685",
        "name": "Boiler",
        "field": "payload",
        "fieldType": "msg",
        "format": "html",
        "syntax": "mustache",
        "template": "<!DOCTYPE html>\n<html lang=\"id\">\n\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\">\n  <title>Display Monitoring - Boiler</title>\n  <style>\n    :root {\n      --design-w: 1024;\n      --design-h: 600;\n      --bg: #f8f9fb;\n      --card: #fff;\n      --border-color: #e0e0e0;\n      --text-color: #222;\n      --muted: #6b7280;\n      --green: #28a745;\n      --red: #dc3545;\n      --blue: #007bff;\n      --radius: 8px;\n      --ui-font: \"Inter\", system-ui, -apple-system, \"Segoe UI\", Roboto, Arial;\n    }\n\n    html,\n    body {\n      height: 100%;\n      margin: 0;\n      padding: 0;\n      background: var(--bg);\n      font-family: var(--ui-font);\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n      overflow: auto;\n    }\n\n    .viewport {\n      width: 100%;\n      height: 100%;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 8px;\n      box-sizing: border-box;\n      background: var(--bg);\n    }\n\n    .app {\n      width: calc(var(--design-w)*1px);\n      height: calc(var(--design-h)*1px);\n      background: var(--card);\n      border-radius: calc(var(--radius)+2px);\n      padding: 12px;\n      box-sizing: border-box;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      transform-origin: top center;\n      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);\n      border: 1px solid var(--border-color);\n      overflow: hidden;\n      -webkit-user-select: none;\n      user-select: none;\n    }\n\n    header {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      position: relative;\n      padding: 4px 8px;\n    }\n\n    .header-title {\n      font-size: 20px;\n      font-weight: 800;\n      letter-spacing: 0.6px;\n    }\n\n    #connection-status {\n      position: absolute;\n      right: 10px;\n      top: 8px;\n      font-size: 13px;\n      font-weight: 800;\n      padding: 6px 10px;\n      border-radius: 10px;\n      color: #fff;\n    }\n\n    #connection-status.connected {\n      background: var(--green);\n    }\n\n    #connection-status.disconnected {\n      background: var(--red);\n    }\n\n    .boiler-status {\n      display: flex;\n      gap: 10px;\n      align-items: stretch;\n    }\n\n    .boiler-box {\n      flex: 1 1 0;\n      min-width: 0;\n      background: #fff;\n      border: 1px solid var(--border-color);\n      border-radius: 10px;\n      padding: 12px;\n      text-align: center;\n      box-sizing: border-box;\n    }\n\n    .boiler-box strong {\n      display: block;\n      margin-bottom: 6px;\n      font-size: 15px;\n      color: var(--text-color);\n    }\n\n    .boiler-box .value {\n      font-weight: 800;\n      font-size: 15px;\n      color: #111;\n    }\n\n    .chart-area {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      flex: 1 1 0;\n      min-height: 0;\n    }\n\n    .chart-card {\n      display: flex;\n      flex-direction: column;\n      width: 100%;\n      flex: 1 1 0;\n      min-height: 0;\n      background: var(--card);\n      border-radius: 10px;\n      padding: 12px;\n      box-sizing: border-box;\n      position: relative;\n    }\n\n    .chart-header {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      gap: 8px;\n      flex: 0 0 auto;\n    }\n\n    .chart-title {\n      font-weight: 800;\n      font-size: 16px;\n      margin: 0;\n      color: #111;\n    }\n\n    .range-text {\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    .legend-container {\n      display: flex;\n      justify-content: center;\n      gap: 8px;\n      overflow-x: auto;\n      padding-bottom: 6px;\n      align-items: center;\n      flex: 0 0 auto;\n      max-width: 100%;\n    }\n\n    .legend-button {\n      border: none;\n      border-radius: 999px;\n      color: #fff;\n      font-weight: 800;\n      padding: 8px 12px;\n      cursor: pointer;\n      font-size: 13px;\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      white-space: nowrap;\n      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);\n    }\n\n    .legend-button.hidden {\n      opacity: 0.34;\n      filter: grayscale(1);\n      box-shadow: none;\n    }\n\n    .c-boiler1 {\n      background: #ff1e1e;\n    }\n\n    .c-boiler2 {\n      background: #f39c12;\n    }\n\n    .c-boiler3 {\n      background: #ffd400;\n      color: #111;\n    }\n\n    .chart-canvas {\n      flex: 1 1 0;\n      position: relative;\n      z-index: 10;\n      min-height: 220px;\n      display: block;\n      width: 100%;\n      aspect-ratio: 16/6;\n    }\n\n    .chart-canvas canvas {\n      width: 100% !important;\n      height: 100% !important;\n      display: block;\n      border-radius: 6px;\n      background: #fff;\n    }\n\n    .note {\n      display: flex;\n      gap: 12px;\n      align-items: flex-start;\n      background: #f6f6f7;\n      border-radius: 10px;\n      padding: 12px;\n      border: 1px solid #e6e6e6;\n      box-sizing: border-box;\n      flex: 0 0 auto;\n    }\n\n    .note-left {\n      width: 65%;\n    }\n\n    .note-right {\n      width: 35%;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n\n    .note label {\n      font-weight: 800;\n      display: block;\n      margin-bottom: 6px;\n    }\n\n    select,\n    textarea,\n    input {\n      width: 100%;\n      padding: 10px;\n      border-radius: 8px;\n      border: 1px solid #cfcfcf;\n      box-sizing: border-box;\n      font-size: 14px;\n      font-family: var(--ui-font);\n    }\n\n    button {\n      background: var(--blue);\n      color: #fff;\n      border: none;\n      padding: 10px 14px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-weight: 800;\n      font-size: 15px;\n    }\n\n    @media (max-width:980px) {\n      .app {\n        transform-origin: top left;\n      }\n\n      .boiler-status {\n        flex-direction: column;\n      }\n\n      .note-left,\n      .note-right {\n        width: 100%\n      }\n\n      .note {\n        flex-direction: column;\n      }\n\n      .chart-canvas {\n        min-height: 200px;\n        aspect-ratio: 16/9;\n      }\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"viewport\">\n    <div class=\"app\" id=\"app\" aria-label=\"Display Monitoring Boiler\">\n      <header>\n        <div class=\"header-title\">DISPLAY MONITORING — BOILER</div>\n        <div id=\"connection-status\" class=\"disconnected\" aria-live=\"polite\">DISCONNECTED</div>\n      </header>\n\n      <div class=\"boiler-status\" aria-label=\"Boiler status\">\n        <div class=\"boiler-box\"><strong id=\"ds-label-0\">BOILER 01</strong>\n          <div id=\"ds-pressure-0\" class=\"value\">Pressure: -- bar</div>\n        </div>\n        <div class=\"boiler-box\"><strong id=\"ds-label-1\">BOILER 02</strong>\n          <div id=\"ds-pressure-1\" class=\"value\">Pressure: -- bar</div>\n        </div>\n        <div class=\"boiler-box\"><strong id=\"ds-label-2\">BOILER 03</strong>\n          <div id=\"ds-pressure-2\" class=\"value\">Pressure: -- bar</div>\n        </div>\n      </div>\n\n      <div class=\"chart-area\" aria-label=\"Chart area\">\n        <div class=\"chart-card\" aria-live=\"polite\">\n          <div class=\"chart-header\">\n            <div class=\"chart-title\">Boiler Pressure</div>\n            <div class=\"range-text\" id=\"rangeText\">Range Y: auto</div>\n          </div>\n\n          <div id=\"legendButtons\" class=\"legend-container\" role=\"toolbar\" aria-label=\"Chart Legend\"></div>\n\n          <div class=\"chart-canvas\">\n            <canvas id=\"mainChart\" aria-label=\"Grafik tekanan boiler\"></canvas>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"note\" role=\"region\" aria-label=\"Laporan Gangguan / Catatan\">\n        <div class=\"note-left\">\n          <label for=\"noteType\">Laporan Gangguan / Catatan</label>\n          <select id=\"noteType\" aria-label=\"Tipe laporan\">\n            <option value=\"operational\">Operational hour</option>\n            <option value=\"maintenance\">Maintenance</option>\n          </select>\n          <label for=\"noteText\" style=\"margin-top:8px;\">Keterangan:</label>\n          <textarea id=\"noteText\" rows=\"4\" placeholder=\"Tulis catatan di sini...\" aria-label=\"Keterangan\"></textarea>\n        </div>\n        <div class=\"note-right\">\n          <div style=\"font-weight:800;\">Aksi</div>\n          <button id=\"sendNoteBtn\" type=\"button\" aria-label=\"Kirim Laporan\">Kirim Laporan</button>\n          <div id=\"noteStatus\" class=\"note-status\" aria-live=\"polite\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n\n(function(){\n  const CONFIG = { MAX_POINTS: 50, WINDOW_SECONDS: 5*60, WS_PATH:'/ws/mqtt', TARGET_FPS:25 };\n  const DATASETS = [\n    { label:'Boiler 1', field:'boiler.1', color:'#ff1e1e', id:'ds-pressure-0', css:'c-boiler1' },\n    { label:'Boiler 2', field:'boiler.2', color:'#f39c12', id:'ds-pressure-1', css:'c-boiler2' },\n    { label:'Boiler 3', field:'boiler.3', color:'#ffd400', id:'ds-pressure-2', css:'c-boiler3' }\n  ]};\n\n  const STATE = {\n    times: [],\n    series: DATASETS.map(()=>[]),\n    labels: [],\n    visible: DATASETS.map(()=>true),\n    ws: null,\n    reconnectTimer: null,\n    reconnectAttempts: 0\n  };\n\n  const ui = {\n    conn: document.getElementById('connection-status'),\n    legend: document.getElementById('legendButtons'),\n    canvas: document.getElementById('mainChart'),\n    dsEls: DATASETS.map(d => d.id ? document.getElementById(d.id) : null),\n    sendNoteBtn: document.getElementById('sendNoteBtn'),\n    noteText: document.getElementById('noteText'),\n    noteType: document.getElementById('noteType'),\n    noteStatus: document.getElementById('noteStatus'),\n    rangeText: document.getElementById('rangeText')\n  };\n\n  const canvas = ui.canvas;\n  const ctx = canvas.getContext && canvas.getContext('2d');\n\n  (function applyScale(){\n    const designW = 1024, designH = 600;\n    const app = document.getElementById('app');\n    function fn(){\n      const vw = Math.max(320, window.innerWidth);\n      const vh = Math.max(240, window.innerHeight);\n      const pad = 16;\n      const scale = Math.min((vw - pad) / designW, (vh - pad) / designH, 1);\n      app.style.transform = 'scale(' + scale + ')';\n      const top = Math.max(0, (vh - designH * scale) / 2);\n      app.style.marginTop = top + 'px';\n      window.dispatchEvent(new Event('hmi-resize'));\n    }\n    window.addEventListener('resize', fn);\n    window.addEventListener('orientationchange', fn);\n    requestAnimationFrame(fn);\n  })();\n\n  let gridCache = null;\n  let lastViewport = { w:0, h:0, dpr:0 };\n  function fit(){\n    if(!canvas) return;\n    const container = canvas.parentElement;\n    const rect = container.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    const w = Math.max(1, Math.round(rect.width * dpr));\n    const h = Math.max(1, Math.round(rect.height * dpr));\n    if(canvas.width !== w || canvas.height !== h || lastViewport.dpr !== dpr || lastViewport.w !== rect.width || lastViewport.h !== rect.height){\n      canvas.width = w; canvas.height = h;\n      canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';\n      if(ctx) ctx.setTransform(dpr,0,0,dpr,0,0);\n      lastViewport = { w: rect.width, h: rect.height, dpr };\n      buildGridCache();\n    }\n  }\n  window.addEventListener('hmi-resize', fit);\n  window.addEventListener('resize', fit);\n\n  function buildGridCache(){\n    if(!canvas) return;\n    const container = canvas.parentElement;\n    const rect = container.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    const cssW = rect.width, cssH = rect.height;\n    const pixelW = Math.max(1, Math.round(cssW * dpr));\n    const pixelH = Math.max(1, Math.round(cssH * dpr));\n    if(gridCache && lastViewport.w === cssW && lastViewport.h === cssH && lastViewport.dpr === dpr) return;\n    const c = document.createElement('canvas');\n    c.width = pixelW; c.height = pixelH;\n    c.style.width = cssW + 'px'; c.style.height = cssH + 'px';\n    const g = c.getContext('2d');\n    g.setTransform(dpr,0,0,dpr,0,0);\n    const pad = { l:58, r:12, t:14, b:44 };\n    const plotW = cssW - pad.l - pad.r;\n    const plotH = cssH - pad.t - pad.b;\n    g.fillStyle = '#fff'; g.fillRect(pad.l-1, pad.t-1, plotW+2, plotH+2);\n    g.strokeStyle = '#eef2f7'; g.lineWidth = 1;\n    const rows = 4;\n    for(let r=0;r<=rows;r++){\n      const y = pad.t + plotH * r / rows + 0.5;\n      g.beginPath(); g.moveTo(pad.l, y); g.lineTo(pad.l + plotW, y); g.stroke();\n    }\n    gridCache = c;\n  }\n\n  function binarySearchInsertIndex(arr, ts){\n    let lo=0, hi=arr.length;\n    while(lo<hi){\n      const mid=(lo+hi)>>1;\n      if(arr[mid] < ts) lo = mid+1; else hi = mid;\n    }\n    return lo;\n  }\n  function getNested(obj,path){\n    try { return path.split('.').reduce((o,p) => o!=null ? o[p] : null, obj); } catch(e){ return null; }\n  }\n\n\n  function pushPayload(payload, tsInput){\n    let ts = null;\n    if(typeof tsInput === 'number' && isFinite(tsInput)) ts = tsInput;\n    else if(payload && typeof payload.ts === 'number' && isFinite(payload.ts)) ts = payload.ts;\n    else if(payload && payload.time){\n      const parsed = Date.parse(payload.time);\n      if(!isNaN(parsed)) ts = parsed/1000;\n    }\n    if(ts == null || !isFinite(ts)) ts = Date.now()/1000;\n    const label = new Date(ts*1000).toLocaleTimeString('id-ID', {hour:'2-digit', minute:'2-digit', second:'2-digit'});\n    const idx = binarySearchInsertIndex(STATE.times, ts);\n    \n    if(idx === STATE.times.length){\n      STATE.times.push(ts);\n      STATE.labels.push(label);\n      DATASETS.forEach((d,i) => {\n        const raw = getNested(payload, d.field);\n        let v = null;\n        if(raw == null) v = null;\n        else if(typeof raw === 'number') v = raw;\n        else { const n = Number(raw); v = Number.isFinite(n) ? n : null; }\n        STATE.series[i].push(v);\n      });\n    } else {\n      STATE.times.splice(idx,0,ts);\n      STATE.labels.splice(idx,0,label);\n      DATASETS.forEach((d,i) => {\n        const raw = getNested(payload, d.field);\n        let v = null;\n        if(raw == null) v = null;\n        else if(typeof raw === 'number') v = raw;\n        else { const n = Number(raw); v = Number.isFinite(n) ? n : null; }\n        STATE.series[i].splice(idx,0,v);\n      });\n    }\n    \n    const cutoff = ts - CONFIG.WINDOW_SECONDS;\n    const cutIdx = binarySearchInsertIndex(STATE.times, cutoff);\n    if(cutIdx > 0){\n      STATE.times = STATE.times.slice(cutIdx);\n      STATE.labels = STATE.labels.slice(cutIdx);\n      for(let s=0;s<STATE.series.length;s++) STATE.series[s] = STATE.series[s].slice(cutIdx);\n    }\n    \n    if(STATE.times.length > CONFIG.MAX_POINTS){\n      const extra = STATE.times.length - CONFIG.MAX_POINTS;\n      STATE.times = STATE.times.slice(extra);\n      STATE.labels = STATE.labels.slice(extra);\n      for(let s=0;s<STATE.series.length;s++) STATE.series[s] = STATE.series[s].slice(extra);\n    }\n    \n    DATASETS.forEach((d,i) => {\n      if(d.id && ui.dsEls[i]){\n        const arr = STATE.series[i];\n        let last = null;\n        for(let k=arr.length-1;k>=0;k--){ const v = arr[k]; if(typeof v === 'number'){ last = v; break; } }\n        ui.dsEls[i].textContent = last == null ? 'Pressure: --' : 'Pressure: ' + Number(last).toFixed(2) + ' bar';\n      }\n    });\n    dirty = true;\n  }\n\n  function computeYRange(){\n    let all = [];\n    for(let i=0;i<STATE.series.length;i++){\n      if(!STATE.visible[i]) continue;\n      const s = STATE.series[i];\n      for(let k=0;k<s.length;k++){\n        const v = s[k];\n        if(typeof v === 'number') all.push(v);\n      }\n    }\n    if(!all.length) return {min:0, max:30}; \n    const minData = Math.min(...all), maxData = Math.max(...all);\n    let span = Math.max(0.0001, maxData - minData);\n    const pad = Math.max(0.5, span * 0.12);\n    let min = Math.max(0, minData - pad);\n    let max = maxData + pad;\n    \n    if(max < 6) max = 6;\n    return { min, max };\n  }\n\n\n  function draw(displayNowSec){\n    if(!ctx) return;\n    fit();\n    const containerRect = canvas.parentElement.getBoundingClientRect();\n    const rect = { width: containerRect.width, height: containerRect.height };\n    const pad = { l:58, r:12, t:14, b:44 };\n    const plotW = rect.width - pad.l - pad.r;\n    const plotH = rect.height - pad.t - pad.b;\n    ctx.clearRect(0,0,rect.width,rect.height);\n    if(gridCache) ctx.drawImage(gridCache, 0, 0, rect.width, rect.height);\n    else { ctx.fillStyle='#fff'; ctx.fillRect(pad.l-1,pad.t-1,plotW+2,plotH+2); }\n    \n    let endTime = displayNowSec;\n    let startTime = endTime - CONFIG.WINDOW_SECONDS;\n    if(STATE.times.length){\n      const first = STATE.times[0], last = STATE.times[STATE.times.length-1];\n      const dataSpan = last - first;\n      if(dataSpan < CONFIG.WINDOW_SECONDS){ startTime = first; endTime = startTime + CONFIG.WINDOW_SECONDS; }\n      else { endTime = Math.max(endTime, last); startTime = endTime - CONFIG.WINDOW_SECONDS; }\n    }\n    \n    const pr = computeYRange();\n    ui.rangeText.textContent = `Y: ${pr.min.toFixed(2)}–${pr.max.toFixed(2)} bar · X: 30 menit`;\n    ctx.fillStyle = '#374151'; ctx.font = '12px system-ui'; ctx.textAlign = 'right';\n    const yRows = 4;\n    for(let r=0;r<=yRows;r++){\n      const frac = 1 - (r / yRows);\n      const val = pr.min + (pr.max - pr.min) * frac;\n      const y = pad.t + (plotH * r / yRows);\n      ctx.fillText(Number(val.toFixed(2)) + ' bar', pad.l - 8, y + 4);\n    }\n    \n    ctx.fillStyle = '#6b7280'; ctx.font = '12px system-ui'; ctx.textAlign = 'center';\n    \n    const startIdx = binarySearchInsertIndex(STATE.times, startTime);\n    const endIdx = binarySearchInsertIndex(STATE.times, endTime + 0.000001);\n    const visibleCount = Math.max(0, endIdx - startIdx);\n    if(!visibleCount){\n      \n      const labelCount = 5;\n      for(let k=0;k<labelCount;k++){\n        const ts = startTime + k*(endTime - startTime)/(labelCount-1 || 1);\n        const x = pad.l + plotW * (k/(labelCount-1 || 1));\n        ctx.save(); ctx.translate(x, pad.t + plotH + 18); ctx.rotate(-Math.PI/10); ctx.textAlign='right';\n        ctx.fillText(new Date(ts*1000).toLocaleTimeString('id-ID',{hour:'2-digit',minute:'2-digit'}), 0,0); ctx.restore();\n      }\n    } else {\n      const maxXLabels = Math.min(6, Math.max(2, Math.floor(plotW / 90)));\n      const step = Math.max(1, Math.floor(visibleCount / maxXLabels));\n      for(let ii=startIdx; ii<endIdx; ii+=step){\n        const ts = STATE.times[ii];\n        const fracX = (ts - startTime) / (endTime - startTime);\n        const x = pad.l + plotW * fracX;\n        ctx.save(); ctx.translate(x, pad.t + plotH + 18); ctx.rotate(-Math.PI/6); ctx.textAlign='right';\n        ctx.fillText(new Date(ts*1000).toLocaleTimeString('id-ID',{hour:'2-digit',minute:'2-digit'}), 0,0); ctx.restore();\n      }\n    }\n    \n    for(let si=0; si<DATASETS.length; si++){\n      if(!STATE.visible[si]) continue;\n      const d = DATASETS[si];\n      const times = STATE.times;\n      const arr = STATE.series[si];\n      if(!times.length) continue;\n      ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = d.color; ctx.fillStyle = d.color;\n      let started=false;\n      for(let j=startIdx;j<endIdx;j++){\n        const t = times[j];\n        const v = arr[j];\n        if(t==null || v==null || isNaN(v)){ started=false; continue; }\n        if(t < startTime || t > endTime){ started=false; continue; }\n        const fracX = (t - startTime) / (endTime - startTime);\n        const x = pad.l + plotW * fracX;\n        const norm = (v - pr.min) / Math.max(0.000001, (pr.max - pr.min));\n        const y = pad.t + plotH * (1 - Math.max(0, Math.min(1, norm)));\n        if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y);\n      }\n      ctx.stroke();\n      \n      ctx.save(); ctx.fillStyle = d.color;\n      const visiblePts = Math.max(1, endIdx - startIdx);\n      const sampleStep = Math.max(1, Math.floor(visiblePts / 300));\n      for(let j=startIdx;j<endIdx;j+=sampleStep){\n        const v = arr[j];\n        if(v==null || isNaN(v)) continue;\n        const t = times[j];\n        const fracX = (t - startTime) / (endTime - startTime);\n        const x = pad.l + plotW * fracX;\n        const norm = (v - pr.min) / Math.max(0.000001, (pr.max - pr.min));\n        const y = pad.t + plotH * (1 - Math.max(0, Math.min(1, norm)));\n        ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();\n      }\n      ctx.restore();\n    }\n    \n    ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = 1; ctx.strokeRect(Math.round(pad.l)+0.5, Math.round(pad.t)+0.5, Math.round(plotW)-1, Math.round(plotH)-1);\n  }\n\n  let raf = null, lastFrameTime = 0, lastFullDraw = 0, dirty = true;\n  const frameInterval = 1000 / CONFIG.TARGET_FPS;\n  function anim(now){\n    if(!now) now = performance.now();\n    if(now - lastFrameTime >= frameInterval){\n      if(dirty || (now - lastFullDraw >= 1000)){\n        lastFrameTime = now - ((now - lastFrameTime) % frameInterval);\n        const nowSec = Date.now()/1000;\n        draw(nowSec);\n        dirty = false; lastFullDraw = now;\n      }\n    }\n    raf = requestAnimationFrame(anim);\n  }\n\n  function renderLegend(){\n    ui.legend.innerHTML = '';\n    DATASETS.forEach((d,i)=>{\n      const btn = document.createElement('button');\n      btn.className = 'legend-button ' + (d.css || '');\n      btn.style.background = d.color;\n      btn.textContent = d.label;\n      btn.dataset.i = i;\n      btn.setAttribute('aria-pressed', String(!!STATE.visible[i]));\n      btn.addEventListener('click', ()=>{\n        const idx = Number(btn.dataset.i);\n        STATE.visible[idx] = !STATE.visible[idx];\n        btn.classList.toggle('hidden', !STATE.visible[idx]);\n        btn.setAttribute('aria-pressed', String(!!STATE.visible[idx]));\n        dirty = true;\n      });\n      ui.legend.appendChild(btn);\n    });\n    fit();\n  }\n  renderLegend();\n\n  function wsUrl(){ if(window.HMI_WS_URL) return window.HMI_WS_URL; const proto = (location.protocol==='https:') ? 'wss:' : 'ws:'; return proto + '\n  function setConn(connected){ ui.conn.textContent = connected ? 'CONNECTED' : 'DISCONNECTED'; ui.conn.classList.toggle('connected', connected); ui.conn.classList.toggle('disconnected', !connected); }\n  function scheduleReconnect(){ STATE.reconnectAttempts++; const delay = Math.min(1000 * Math.pow(2, Math.min(STATE.reconnectAttempts,6)), 30000); if(STATE.reconnectTimer) clearTimeout(STATE.reconnectTimer); STATE.reconnectTimer = setTimeout(connectWS, delay); }\n  function connectWS(){\n    if(STATE.ws && (STATE.ws.readyState === WebSocket.OPEN || STATE.ws.readyState === WebSocket.CONNECTING)) return;\n    try { STATE.ws = new WebSocket(wsUrl()); } catch(e){ console.warn('WS create error', e); setConn(false); scheduleReconnect(); return; }\n    STATE.ws.onopen = ()=> { STATE.reconnectAttempts = 0; setConn(true); if(STATE.reconnectTimer){ clearTimeout(STATE.reconnectTimer); STATE.reconnectTimer = null; } };\n    STATE.ws.onmessage = (evt)=> { try { const j = JSON.parse(evt.data); \n        pushPayload(j); } catch(e){ console.warn('Invalid message', e); } };\n    STATE.ws.onclose = ()=> { setConn(false); scheduleReconnect(); };\n    STATE.ws.onerror = (err)=> { console.error('WS error', err); };\n  }\n\n  ui.sendNoteBtn && ui.sendNoteBtn.addEventListener('click', ()=>{\n    const text = ui.noteText.value.trim(); const type = ui.noteType.value;\n    if(!text){ alert('Keterangan kosong'); return; }\n    const payload = { cmd:'note', type, text, time: new Date().toISOString() };\n    if(STATE.ws && STATE.ws.readyState === WebSocket.OPEN){\n      STATE.ws.send(JSON.stringify(payload));\n      ui.noteStatus.textContent = 'Laporan terkirim'; ui.noteStatus.className = 'note-status success';\n      ui.noteText.value = ''; setTimeout(()=>{ ui.noteStatus.textContent=''; ui.noteStatus.className=''; }, 3000);\n    } else {\n      ui.noteStatus.textContent = 'WS tidak terhubung'; ui.noteStatus.className = 'note-status error';\n      setTimeout(()=>{ ui.noteStatus.textContent=''; ui.noteStatus.className=''; }, 3000);\n    }\n  });\n\n  fit(); if(!raf) raf = requestAnimationFrame(anim);\n  setConn(false); connectWS();\n  window.__hmi = { pushPayload, STATE, CONFIG };\n  setTimeout(()=>{\n    if(!STATE.ws || STATE.ws.readyState !== WebSocket.OPEN){\n      const now = Date.now()/1000;\n      for(let k=0;k<120;k++){\n        const t = now - (119 - k) * 10; \n        const s = {\n          boiler: { '1': 22.0 + Math.sin(k/8)*0.4, '2': 21.5 + Math.cos(k/7)*0.35, '3': 22.4 + Math.sin(k/10)*0.25 }\n        };\n        pushPayload(s, t);\n      }\n    }\n  }, 400);\n\n})();\n  </script>\n</body>\n\n</html>",
        "output": "str",
        "x": 410,
        "y": 100,
        "wires": [
            [
                "c239e5aefe9fe3a5"
            ]
        ]
    }
]